% !Mode:: "Tex:UTF-8"

\documentclass[10pt,a4paper]{article}
\usepackage{etoolbox}
\newtoggle{color}
%\togglefalse{color}
\toggletrue{color}


<<eval=FALSE, purl=FALSE, echo=FALSE>>=
setwd("~/Dropbox/PostDataFernando/TutorialesPython")
source('~/Dropbox/Code/R/raptor/raptor.R')
# defaultExecOrder=Inf
# filename = "Tutorial-03-py.Rnw"
# language = c("python")
# fileOverwrite = TRUE
# keepAux = FALSE
raptor(filename = "Tutorial-03-py.Rnw", language = c("python"), fileOverwrite = TRUE, keepAux = FALSE)
@




\usepackage{makeidx}
\newcommand{\idioma}{spanish}
\newcommand{\opcionesIdioma}{,es-nodecimaldot,es-tabla}
\input{../tex/definiciones}
%\input{sahp}
\includecomment{com}

\newtoggle{distribuir}
%\togglefalse{distribuir}
\toggletrue{distribuir}
\iftoggle{distribuir}{%
  % color version
    \includecomment{distribuir}
    \excludecomment{noDistribuir}
}{%
  % b/w version
    \includecomment{noDistribuir}
    \excludecomment{distribuir}
}


\usepackage{attachfile}

\textwidth=150mm \textheight=260mm
\hoffset=-1cm
\voffset=-25mm
\parskip=2mm
%\textwidth=160mm \textheight=240mm \hoffset=-20mm \voffset=-20mm \parskip=0mm \marginparsep=-25mm

\setlength{\parindent}{0pt}
\newcounter {cont01}

\externaldocument[curso-]{../CursoIntroduccionEstadistica/000-CursoEstadistica}
\externaldocument[tut01-]{../TutorialesR/Tutorial-01}
\externaldocument[tut02-]{Tutorial-02-py}
%\externaldocument[tut03-]{Tutorial-03}



<<echo=FALSE, purl=FALSE, results='hide', message=FALSE, error=TRUE, warning=FALSE>>=
# system("R CMD BATCH Tutorial-03-py-procesar.R", intern = TRUE)
jupyterCol = "#ffffe6"
codeColor = "#e6f7ff"
@

<<echo=FALSE, purl=FALSE, results='hide', message=FALSE, error=TRUE, warning=FALSE>>=
library(knitr)
DeMere1 = FALSE
read_chunk("./code/Tut-03-DeMere01.out")
probGeom1 = FALSE
read_chunk("./code/Tut-03-probGeom1.out")
@









\begin{document}
<<echo=FALSE>>=
library(knitr)
read_chunk('rptAux/Tutorial-03-py-gz0yx4iho-generic-python.out')
@
%\SweaveOpts{concordance=TRUE}
\includecomment{pdf}
%\excludecomment{pdf}
%\includecomment{dvi}
\excludecomment{dvi}
%\includecomment{com}
\excludecomment{com}

\paragraph{\link{http://www.postdata-statistics.com/}{PostData}\hspace{6.3cm}Curso de Introducción a la Estadística\\[2mm]} \noindent\hrule

\setcounter{section}{0}
\section*{\hspace{-0.1cm}\fbox{\colorbox{Gris025}{
\begin{minipage}{14.5cm}
Tutorial 03 (versión Python): Probabilidad.
\end{minipage}
}}}
{
Atención:
\begin{itemize}
  \item Este documento pdf lleva adjuntos algunos de los ficheros de datos necesarios. Y está pensado para trabajar con él directamente en tu ordenador. Al usarlo en la pantalla, si es necesario, puedes aumentar alguna de las figuras para ver los detalles. Antes de imprimirlo, piensa si es necesario. Los árboles y nosotros te lo agradeceremos.
  \item Fecha: \today. Si este fichero tiene más de un año, puede resultar obsoleto. Busca si existe una versión más reciente.
\end{itemize}
}
\setcounter{tocdepth}{1}
\tableofcontents

\noindent{\bf \\
}

En la segunda parte del curso estamos aprendiendo el lenguaje matemático de la teoría de la Probabilidad que, ya en la tercera parte, nos va a resultar necesario para poder hacer Inferencia. En esta segunda parte del curso el nivel matemático se eleva, con la aparición de la Combinatoria, y de nociones del Cálculo, como las integrales. ¡Pero que nadie se asuste! En este tutorial vamos a tratar de poner los medios para aprender a calcular, de la forma más simple posible, lo que vamos a necesitar. Entre otras cosas, nos apoyaremos en el ordenador para evitarnos parte de los cálculos más difíciles.


\section{Los problemas del Caballero de Méré.}
\label{tut03:sec:NumerosAleatoriosRSample}

Para poder hacer experimentos relacionados con la idea de probabilidad, necesitamos ser capaces de generar valores al azar. En los dos tutoriales previos, hemos avanzado algunas ideas de la forma en que podemos usar Calc y Python para esa tarea. Recordemos brevemente lo que hemos hecho hasta ahora:

\begin{itemize}
  \item En la página \pageref{tut01-tut01:subsubsec:NumerosAleatoriosCalc} del Tutorial-01 hemos aprendido a usar la función {\tt ALEATORIO.ENTRE} de Calc.
  \item En la Sección \ref{tut02-tut02:subsec:numerosAleatorios} del Tutorial-02 (pág. \pageref{tut02-tut02:subsec:numerosAleatorios}) hemos aprendido métodos básicos para generar números aleatorios en Python. Aquí vamos a aprovecharnos de esos métodos para hacer experimentos relacionados con la Probabilidad.
  \item También en ese Tutorial, concretamente en la Sección \ref{tut02-tut02:subsec:numerosAleatoriosReproduciblesSeed} (pág. \pageref{tut02-tut02:subsec:numerosAleatoriosReproduciblesSeed}), hemos aprendido a usar la función {\tt seed} de Python para que los resultados sean reproducibles. En Calc puede hacerse algo parecido con el {\em pegado especial}, pero es una herramienta mucho más incómoda que en Python\footnote{Puedes ver los detalles en este enlace (en inglés):\\ \link{https://wiki.openoffice.org/wiki/Documentation/How_Tos/Calc:_RAND_function}{https://wiki.openoffice.org/wiki/Documentation/How\_Tos/Calc:\_RAND\_function}}.
  \item Hemos insistido en la idea de que, en cualquier caso, los números que se generan con el ordenador son pseudoaleatorios (la propia existencia de {\tt set.seed} es una prueba de esto). Pero podemos tranquilizar al lector: a todos los efectos, la diferencia entre estos números pseudoaleatorios y los números verdaderamente aleatorios es tan sutil, que no va a suponer ningún problema en este curso.
\end{itemize}

\subsection{La función {\tt ALEATORIO.ENTRE} de Calc y los problemas del Caballero de Méré.}

La función {\tt ALEATORIO.ENTRE} de Calc es suficiente para los primeros experimentos sencillos sobre la Regla de Laplace y, por ejemplo, los problemas del Caballero de Méré (ver la Sección \ref{curso-cap03:sec:PrimerasNocionesProbabilidad}, pág. \pageref{curso-cap03:sec:PrimerasNocionesProbabilidad} del libro). Para centrar la discusión, hemos aprendido que, por ejemplo,
\begin{verbatim}
  ALEATORIO.ENTRE(20;80)
\end{verbatim}
produce un número (pseudo)aleatorio entre $20$ y $80$. Con el lenguaje que estamos desarrollando en el Capítulo \ref{curso-cap:Probabilidad}, podemos añadir que todos los resultados entre $20$ y $80$ son equiprobables. Si queremos conseguir más de un número, debemos copiar esa fórmula en más celdas de la hoja de cálculo. Cada vez que abras o cierres la hoja de cálculo, los números generados con  {\tt ALEATORIO.ENTRE} cambiarán. Y si deseas generar nuevos valores, sin tener que cerrar y abrir la hoja de cálculo, puedes utilizar la combinación de teclas {\tt Ctrl+Mayús+F9}.


Vamos a usar la función para ilustrar los problemas del Caballero de Méré que hemos descrito en la Sección \ref{curso-cap03:sec:PrimerasNocionesProbabilidad} (pág. \pageref{curso-cap03:sec:PrimerasNocionesProbabilidad}). Concretamente, hemos adjuntado a este documento dos hojas de cálculo,
\begin{center}
  \begin{enumerate}
    \item \fichero{../ods/Tut03-DeMere1.ods}{Tut03-DeMere1.ods} (para la apuesta (a))
    \item \fichero{../ods/Tut03-DeMere2.ods}{Tut03-DeMere2.ods} (para la apuesta (b))
  \end{enumerate}
\end{center}
en las que hemos {\em simulado} esas dos apuestas, y hemos jugado 1000 veces cada una de ellas. La Figura \ref{tut03:fig:Tut03-DeMere1.ods} muestra el resultado al abrir el primero de esos ficheros. Tus números, al ser aleatorios, serán distintos de los nuestros, pero lo esencial de la discusión seguirá siendo válido.
\begin{figure}[h!]
    \begin{center}
    \includegraphics[width=15cm]{../fig/Tut03-41.png}
    \end{center}
  \caption{El fichero {\tt Tut03-DeMere1.ods} de Calc}
  \label{tut03:fig:Tut03-DeMere1.ods}
\end{figure}
Las primeras cuatro columnas de la hoja de cálculo (de la {\tt A} a la {\tt D}) se han obtenido usando la función {\tt ALEATORIO.ENTRE}. Cada fila, por tanto se corresponde con una jugada, y si examinas el fichero verás que hemos jugado $1000$ veces.  Además, cada vez que pulses {\tt Ctrl+Mayús+F9} obtendrás $1000$ nuevas partidas de este juego. La columna {\tt E} contiene
un $1$ si hemos obtenido (al menos) un $6$ en las cuatro tiradas, y un $0$ si no es así. No queremos entretenernos demasiado en la forma en la que hemos conseguido que Calc haga esto, porque haremos cosas más  sofisticadas con Python, de una manera más sencilla, y merece la pena reservar nuestras fuerzas para ese empeño. Pero si sientes curiosidad, puedes hacer clic sobre la celda {\tt E2}, y ver los comandos de Calc que hemos usado para conseguirlo:
\begin{verbatim}
  =SI(O(A2=6;B2=6;C2=6;D2=6);1;0)
\end{verbatim}
Esencialmente, lo que hemos dicho, en el lenguaje de Calc, es "Si alguna de las celdas {\tt A2, B2, C2, D2} contiene un 6, entonces el resultado es $1$. En caso contrario, es un $0$". Y para eso hemos usado dos funciones de Calc, llamadas {\tt SI} y {\tt O}.

Las columnas {\tt G, H} e {\tt I} contienen el análisis de los resultados en forma de tabla de frecuencias y frecuencias relativas. Las frecuencias relativas son las cantidades que debemos comparar con las probabilidades calculadas de forma teórica, para saber si la teoría de las probabilidades que estamos aplicando es una descripción correcta del fenómeno. Y, en este ejemplo en particular, el resultado nos indica que la teoría del Caballero de Méré no está funcionando.

Recuerda que, según hemos visto en la teoría del curso, la ganancia que el Caballero de Méré esperaba era de un 66\% de lo invertido. Y lo que se observa es que la proporción de apuestas perdidas frente a apuestas ganadas es mucho menor de lo que el Cabllero esperaba.

En la Figura \ref{tut03:fig:Tut03-DeMere2.ods} puedes ver el comienzo del fichero correspondiente al segundo juego del Caballero de Méré. Sin entrar en muchos detalles (¡explora tú mismo el fichero!), las columnas de la izquierda contienen los resultados de las tiradas, que son números del $1$ al $36$, donde el $1$ corresponde a $(1,1)$ y $36$ corresponde a $(6,6)$. Y a la derecha aparece la tabla de frecuencias relativas, que muestra que el resultado es claramente distinto del que hemos obtenido en el otro juego. De hecho, la probabilidad de ganar en este segundo juego es aún más baja que en el otro (es aproximadamente igual a $0.49$). Usa {\tt Ctrl+Mayús+F9} unas cuantas veces para comprobarlo. Y recuerda que el Caballero de Méré creía que la probabilidad de ganar era la misma en ambos juegos.
\begin{figure}[h!]
    \begin{center}
    \includegraphics[width=15cm]{../fig/Tut03-42.png}
    \end{center}
  \caption{El fichero {\tt Tut03-DeMere2.ods} de Calc}
  \label{tut03:fig:Tut03-DeMere2.ods}
\end{figure}
En la página \pageref{curso-cap03:subsubsec:JuegosDeMereCombinatoria} del Capítulo \ref{curso-cap:Probabilidad} del libro se explica cómo calcular las probabilidades correctas para ambos juegos y, más adelante en este tutorial, daremos los detalles computacionales necesarios.

\subsection{Probabilidades y la función {\tt sample} de Python.}

\paragraph{Recordatorio a modo de advertencia:} Recuerda, en lo que sigue, que cuando hablemos de {\em ejecutar} un fragmento de código en Python estamos indicando que puedes usar directamente la {\em Terminal} de Spyder o copiar ese fragmento en el {\em Editor de Código} y ejecutarlo desde allí con las teclas de función. 

Vamos a empezar recordando algo de lo que hemos aprendido sobre la forma de generar números pseudoaleatorios con las funciones del módulo {\tt random}. Si queremos fabricar $100$ números pseudoaleatorios entre $20$ y $80$, usaríamos (como hemos visto en la Sección \ref{tut02-tut02:subsec:numerosAleatorios} del Tutorial-02) un código similar a este que ejecutamos en Jupyter:
<<raptor="python", purl=FALSE, eval=FALSE, background= '#99ccff'>>=
import random as rnd

rnd.seed(2016)

a = 20

b = 80

n = 100

datos = [rnd.randrange(a, b + 1) for _ in range(0, n)]

print(datos)

@
\vspace{-3mm}
<<eval=FALSE, background='#cce6ff'>>=
<<generic-python-chunk-0001>>
@
\noindent



<<chnk1020, eval=FALSE,  purl=FALSE, background=jupyterCol>>=
In [1]: import random as rnd

In [2]: rnd.seed(2016)

In [3]: a = 20

In [4]: b = 80

In [5]: n = 100

In [6]: datos = [rnd.randrange(a, b + 1) for _ in range(0, n)]

In [7]: print(datos)
[67, 75, 48, 77, 55, 76, 73, 36, 76, 63, 79, 65, 25, 72, 38, 28, 24, 51, 78, 50,
26, 39, 28, 29, 40, 33, 42, 33, 35, 30, 51, 48, 79, 65, 40, 25, 66, 60, 55, 35,
37, 58, 75, 72, 69, 62, 22, 39, 56, 76, 32, 47, 40, 21, 60, 44, 24, 39, 68, 48,
26, 31, 53, 57, 22, 44, 57, 32, 75, 80, 42, 70, 62, 34, 42, 23, 44, 53, 23, 36,
51, 65, 65, 43, 63, 69, 43, 31, 60, 39, 64, 23, 59, 66, 56, 22, 57, 78, 67, 75]
@
Hemos usado la función {\tt seed}  para que cuando ejecutes el código obtengas los mismos resultados que nosotros. Si lo deseas, después puedes experimentar ejecutando el código sin usar esa función para comprobar qué es lo que cambia. En cualquier caso, al ejecutar este código los resultados quedan guardados en la lista {\tt datos}.

Al construirlos así todos los números entre $20$ y $80$ son equiprobables. Y, puesto que estamos hablando de Probabilidad, es natural que nos preguntemos: ¿cómo podemos fabricar valores que no sean equiprobables? En el Tutorial-02 nos las ingeniamos para conseguirlo por el procedimiento de aplicar la función {\tt rnd.choice} a vectores en los que había elementos repetidos. Recuerda el ejemplo que veíamos entonces (aquí los resultados concretos son otros, pero no importa):
<<chunk1021, eval=FALSE,  purl=FALSE>>=
muchosUnos = [1,1,1,1,1,1,1,1,1,2]

muestra = [rnd.choice(muchosUnos) for _ in range(0, 100)]

print(muestra)
[1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1]
@
Este método, nos podría servir para conseguir lo que queremos. Pero no resulta una forma cómoda de trabajar, en cuanto las cosas sean un poco más complicadas.
\begin{ejercicio}
\label{tut03:ejercicio01}
\quad\\
Una caja contiene $100$ fichas, idénticas salvo por el número que aparece en ellas. De ellas, $35$ fichas están marcadas con el número $1$, $15$ con el número $2$, $10$ con el número $3$, $10$ con el número $4$ y el resto con el número $5$. Queremos extraer 20 fichas de la caja:
\begin{itemize}
  \item[(a)] con reemplazamiento.
  \item[(b)] sin reemplazamiento.
\end{itemize}
\begin{enumerate}
  \item Escribe el código Python que permite obtener esas $20$ fichas, usando las funciones {\tt sample} y {\tt choice}. Los resultados, para los casos (a) y (b), se guardaran en dos listas, llamadas {\tt sorteo1} y  {\tt sorteo2}, respectivamente. Utiliza {\tt rnd.seed(2016)} como primera línea de tu código, para poder comparar tus resultados con los nuestros.
  \item Obtén las tablas de frecuencias absolutas y relativas de ambos vectores.
  \item ¿Qué tipo de error se produce en Python si tratas de extraer $1000$ fichas sin reemplazamiento?
\end{enumerate}
Solución en la página \pageref{tut03:ejercicio01:sol}.
\qed
\end{ejercicio}

Más adelante se nos planteará una pregunta relacionada con esta, pero ligeramente distinta, en la que el punto de partida son las probabilidades. Imagínate, como ejemplo, que de nuevo tenemos una caja con fichas marcadas del 1 al 5. No sabemos cuántas fichas de cada tipo contiene la caja, pero sí sabemos que la probabilidad de sacar un 1 es del $17.3\%$, la de sacar un $2$ es el $15.2\%$, la de sacar un $3$ es un $27.7\%$ y la de sacar un 4 es un $18.3\%$ (y con eso es suficiente; no hace falta decir cuál es la probabilidad de sacar un 5, ¿verdad?). Si queremos simular la extracción de una muestra de 100 fichas de la caja (con reemplazamiento, así que no hay que preocuparse de que nos quedemos sin fichas), ¿cómo podríamos hacerlo en Python de manera que el código tenga en cuenta esas probabilidades? Para poder responder a esto necesitamos todavía aprender algo más de lenguaje Python. En particular nos resultará muy útil aprender a construir nuestras propias funciones en Python. Cuando lo hayamos hecho volveremos sobre esta cuestión.


\subsection{El primer juego del caballero De Méré en Python.}
\label{tut03:subsec:PrimerJuegoDeMerePyhton}

Para cerrar este apartado y preparar la discusión del siguiente, vamos a pedirle al lector que vuelva un momento a pensar en la Figura \ref{tut03:fig:Tut03-DeMere1.ods} (pág. \pageref{tut03:fig:Tut03-DeMere1.ods}). La tabla del fichero {\tt Tut03-DeMere1.ods} de Calc representa el resultado de $1000$ partidas del primer juego del Caballero de Méré. En ese juego, nosotros agrupamos cuatro tiradas del dado y las llamamos {\em una partida} del juego. Para representar esto en Python vamos a crear una lista para cada partida y guardaremos todas las partidas en una lista de listas. Y de hecho vamos a hacer esto de dos formas: primero usaremos un enfoque clásico de la programación con dos bucles for anidados (recuerda la Sección \ref{tut02-tut02:subsec:buclesForAnidados} del Tutorial02). Este método tiene la ventaja de que resulta sencillo apreciar su estructura. Después usaremos un método que muchos programadores calificarían de {\em más Pythónico:} una comprensión de listas anidada (que ya vimos en esa misma Sección \ref{tut02-tut02:subsec:buclesForAnidados} del Tutorial02).

Vamos con el primer método. El código, que puedes copiar y ejecutar en una sesión de Jupyter es:
<<purl=DeMere1, eval=FALSE, comment=NULL, echo=-1, engine='python'>>=
print("## ---- deMere01ch001")
import random as rnd

rnd.seed(2016)

n = 1000

partidas = []
for i in range(0, n):
  partida = []
  for j in range(0, 4):
    partida.append(rnd.randrange(1, 7))
  partidas.append(partida)
print(partidas[0:5])
@
\vspace{-5mm}
<<purl=FALSE, eval=FALSE, background=codeColor>>=
<<deMere01ch001>>
@
Recuerda que hemos usado {\tt rnd.seed}, así que tus resultados deben coincidir con estos. Fíjate también en que los {\em contadores} {\tt i, j} de los dos bucles {\tt for} no intervienen en ninguna operación y sólo sirven para llevar la cuenta del número de partida (en el caso de {\tt i}) y de la tirada dentro de esa partida (en el caso de {\tt j}).  Otro detalle destacable es que inicializamos la lista {\tt partidas} como una lista vacía antes de comenzar los bucles, e iniciamos una nueva lista {\tt partida} en cada iteración del bucle for externo: la lista {\tt partida} se {\em vacía} así en cada iteración para reutilizarla, guardando en ella los cuatro resultados de una nueva partida.

Como decíamos, la estructura del método es explícita en esta versión con bucles {\tt for} anidados. Frente a estos, el siguiente código con comprensión de listas anidadas resulta indiscutiblemente  más conciso:
<<purl=DeMere1, eval=FALSE, comment=NULL, echo=-1, engine='python'>>=
print("## ---- deMere01ch002")

rnd.seed(2016)

partidas = [[rnd.randrange(1, 7) for _ in range(0, 4)] for _ in range(0, n) ]

print(partidas[0:5])
@
\vspace{-5mm}
<<purl=FALSE, eval=FALSE, background=codeColor>>=
<<deMere01ch002>>
@
La razón por la que los resultados son los mismos es que al ejecutar otra vez {\tt rnd.seed(2016)} hemos reiniciado el generador de números aleatorios de Python y {\em lo hemos colocado en el mismo punto}. Así que a medida que le pedimos números aleatorios a Python, obtenemos las mismas respuestas que antes. Fíjate en que las seis líneas de los bucles for anidados se han reducido a una única línea de código. Fíjate también en que al usar el símbolo {\tt\_} hemos indicado que los contadores no juegan ningún papel adicional. 

\begin{ejercicio}
\label{tut03:ejercicio02}
\quad
En la  Sección \ref{tut02-tut02:subsec:buclesForAnidados} del Tutorial02 vimos un primer ejemplo de comprensión de listas anidadas. Pero allí sólo había una pareja de corchetes {\tt [\,]}, mientras que aquí hemos usado dos parejas anidadas. ¿Por qué? ¿Qué sucede si eliminas la pareja interna de corchetes? Solución en la página \pageref{tut03:ejercicio02:sol}. Recuerda que el ejercicio te resultará mucho más útil si te esfuerzas en resolverlo, sin mirar la solución demasiado pronto.
\qed
\end{ejercicio}

Vamos a analizar los resultados de esas 1000 partidas. Para saber si ha ganado en una partida concreta, el Caballero de Méré tiene que preguntarse si alguno de los cuatro números de esa partida es un 6. La descripción en pseudocódigo de lo que tenemos que hacer es muy sencillo:
<<chunk1005, eval=FALSE,   purl=FALSE, background="#ffe6cc">>=
crear una lista vacía llamada partidaGanadora
para cada partida de la lista partidas:
    si la lista contiene al menos un 6:
        añadir True a partidaGanadora
    en caso contrario
        añadir False a partidaGanadora
@
Seguramente ya te imaginas como traducir casi todo esto a código Python. Sólo hay un detalle que nos falta, pero es el detalle esencial: ¿cómo vamos a decidir si la partida contiene al menos un 6? Hay varias maneras de hacerlo. Antes de seguir es bueno que lo intentes.


\begin{ejercicio}
\label{tut03:ejercicio03}
\quad
Busca una forma de usar Python para decidir si una lista contiene al menos un $6$. Sugerencia: la idea más evidente es usar un bucle {\tt for} para recorrer la lista y ver si cada uno de los elementos es o no un 6.  Solución en la página \pageref{tut03:ejercicio03:sol}.
\qed
\end{ejercicio}
\vspace{6cm}

\begin{center}
  \textcolor{red}{\LARGE\bf ¡No sigas, si no has hecho este ejercicio!}
\end{center}

\newpage

En el Tutorial02 hemos aprendido las ideas básicas sobre valores booleanos y su uso en sentencias del tipo {\tt if}. Allí aprendimos a usar condiciones como {\tt 3 < 5} o como {\tt a == 4}. Pero iremos viendo en este tutorial y a lo largo del curso que hay muchas otras operaciones de Python que dan como resultado un valor booleano {\tt True} o {\tt False}. Concretamente hay una, la operación {\tt in}, que nos permite hacer exactamente la pregunta que necesitamos. Para ver cómo funciona hemos ejecutado dos ejemplos en una sesión de Jupyter:

<<chunk1006, eval=FALSE,   purl=FALSE, background=jupyterCol>>=
In [1]: 6 in [3, 6, 1, 2]
Out[1]: True

In [2]: 6 in [3, 3, 1, 2]
Out[2]: False

In [3]: 6 in [3, 6, 6, 2]
Out[3]: True
@

Usando ese operador {\tt in} la traducción del pseudocódigo para fabricar la lista que identifica las partidas ganadoras es muy sencilla:

<<purl=DeMere1, eval=FALSE, comment=NULL, echo=-1, engine='python'>>=
print("## ---- deMere01ch003")

# Obtenemos una lista de booleanos que caracteriza a las partidas ganadoras
# que son las que contienen al menos un 6.
 
partidasGanadoras = []
for partida in partidas:
    if 6 in partida:
        partidasGanadoras.append(True)
    else:
        partidasGanadoras.append(False)

# Se muestran las 5 primeras para comprobar.

print(partidasGanadoras[0:5])

@
<<purl=FALSE, eval=FALSE, background=codeColor>>=
<<deMere01ch003>>
@
Compara estos resultados con el contenido de cada una de esas 10 primeras listas para comprobar que está funcionando como esperamos.

\begin{ejercicio}
\label{tut03:ejercicio04}
\quad
Aunque el operador {\tt in} nos ha permitido resolver esta cuestión de una forma sencilla, no es la respuesta a todas nuestras posibles preguntas. Por ejemplo, imagínate que queremos saber cuáles son las partidas que contienen exactamente dos seises. ¿Cómo lo harías?
Solución en la página \pageref{tut03:ejercicio04:sol}.
\qed
\end{ejercicio}

Una vez obtenida la lista {\tt partidaGanadora} el siguiente paso es preguntarnos cuántas partidas ganadoras hay en ella. Es decir, cuántas veces aparece el valor {\tt True} en esa lista. Y como sucede a menudo, hay muchas formas de hacerlo. Una de las formas que se te puede ocurrir es hacer una tabla de frecuencia de los valores {\tt True} y {\tt False}:

<<purl=DeMere1, eval=FALSE, comment=NULL, echo=-1, engine='python'>>=
print("## ---- deMere01ch004")

# Tabla de frecuencia

import collections as cl
ganadorasCounter = cl.Counter(partidasGanadoras)
freqGanadoras = ganadorasCounter.most_common()
print(freqGanadoras)

@
\vspace{-5mm}
<<purl=FALSE, eval=FALSE, background=codeColor>>=
<<deMere01ch004>>
@
Otra forma de hacerlo consiste en aprovechar un truco que vimos en la Sección opcional \ref{tut02-tut02:subsubsec:evaluacionOperacionesBooleanas} (pág. \pageref{tut02-tut02:subsubsec:evaluacionOperacionesBooleanas}) del Tutorial02. Allí mostramos que si sumamos o multiplicamos valores booleanos, Python convierte {\tt True} en 1 y {\tt False} en 0. De esa forma, al sumar una lista de valores booleanos el número que obtenemos es el número de valores {\tt True} en esa lista. Algunos ejemplos en Jupyter:
<<eval=FALSE,   purl=FALSE, background=jupyterCol>>=
lista = [True, False, True, True, False, False, True]

sum(lista)
Out[2]: 4

lista = [True, True, True, True, True, False, True]

sum(lista)
Out[4]: 6

lista = [False, False, False, False, False, False, False]

sum(lista)
Out[6]: 0
@
Así que para saber cuantas partidas ganadoras hemos obtenido basta con hacer:
<<purl=DeMere1, eval=FALSE, comment=NULL, echo=-1, engine='python'>>=
print("## ---- deMere01ch005")

print(sum(partidasGanadoras))

@
\vspace{-5mm}
<<purl=FALSE, eval=FALSE, background=codeColor>>=
<<deMere01ch005>>
@
Y el resultado coincide con lo que hemos obtenido usando tablas de frecuencia. A partir de ahí es muy fácil calcular la proporción de partidas ganadoras:
<<purl=DeMere1, eval=FALSE, comment=NULL, echo=-1, engine='python'>>=
print("## ---- deMere01ch006")

# Proporcion de partidas ganadoras

proporcionGanadoras = sum(partidasGanadoras) / n
print(proporcionGanadoras)

@
\vspace{-5mm}
<<purl=FALSE, eval=FALSE, background=codeColor>>=
<<deMere01ch006>>
@
En el libro hemos adelantado que el verdadero valor de la probabilidad de ganar es aproximadamente $0.52$, así que el resultado de esta simulación es una estimación razonablemente buena de esa probabilidad.  Naturalmente, esto es sólo un ejemplo. Pero basta con volver a ejecutar el código (sin usar {\tt rnd.seed}, desde luego) para obtener otro conjunto de partidas y seguir el  experimento, constatando, como hicimos con Calc, que la probabilidad estimada por el Caballero de Méré era errónea. Para facilitar esa tarea, hemos agrupado el código en el fichero adjunto \fichero{./code/Tut-03-DeMere1.py}{Tut-03-DeMere1.py}. Para ejecutarlo en una sesión de Jupyter recuerda usar la {\em función mágica} {\tt run} que vimos en el Tutorial02.

\begin{ejercicio}
\label{tut03:ejercicio05}
\quad
\begin{enumerate}
  \item Abre el fichero en un editor de texto, busca las líneas en las que se ejecuta {\tt rnd.seed} (hay dos) y comenta esas líneas. Recuerda que eso significa que debes añadir el símbolo \verb&#& al principio de cada una de esas líneas. A continuación ejecuta varias veces el programa para ver los resultados que obtienes.
  \item Cambia el valor de $n$ que inicialmente es $1000$ por un valor más grande. Por ejemplo, prueba $n = 10000$. Vuelve a ejecutarlo varias veces y observa los valores que obtienes ahora. ¿Ves alguna diferencia con los del caso anterior?
  \item ¿A partir de qué valor la respuesta deja de parecerte instantánea?
\end{enumerate}
Solución en la página \pageref{tut03:ejercicio05:sol}.
\qed
\end{ejercicio}
La contestación al último apartado de este ejercicio depende de muchos factores y, en particular, de la potencia de tu ordenador. El objetivo es que te des cuenta de que incluso las simulaciones sencillas como esta representan un cierto esfuerzo de cálculo. A medida que afrontes problemas más y más complicados ese esfuerzo irá siendo cada vez más pesado y probablemente te obligará a empezar a preocuparte por el espinoso asunto de la {\sf eficiencia} del código que escribes. Hemos visto que a menudo hay más de una forma de resolver un problema en Python. Pero eso no significa que todas las soluciones sean igual de eficientes. Para no sobrecargarte de información vamos a posponer esta discusión para más adelante. Cuando sepamos un poco más de Python volveremos sobre este tema.


\subsection{El segundo juego}
\label{tut03:subsec:SegundoJuego}

En lugar de hacer una descripción igual de detallada del segundo juego, vamos a proponer al lector que lo aborde mediante un ejercicio.

\begin{ejercicio}
\label{tut03:ejercicio06}
\quad
\begin{enumerate}
  \item Construye una lista {\tt dosDados24000} con $24\cdot 1000$ tiradas de un ``dado'' de 36 caras. El número $36$ corresponde al $6$ doble.
  \item Identifica las partidas ganadoras, aquellas que contienen al menos un seis doble.
  \item Calcula la proporción de partidas ganadoras sobre el total de $1000$ partidas.
\end{enumerate}
Solución en la página \pageref{tut03:ejercicio06:sol}.
\qed
\end{ejercicio}


\subsubsection{Comprobando experimentalmente la regla de Laplace}
\label{tut03:subsubsec:ComprobandoExperimentalmenteReglaLaplace}

Uno de nuestros primeros ejemplos usando la Regla de Laplace, al final de la Sección \ref{curso-cap03:sec:ReglaLaplace} del libro, se refiere al juego en el que tiramos dos veces un dado y queremos calcular la probabilidad del suceso
    \begin{center}
      {\sf  $A=${\em obtener al menos un seis en las dos tiradas.} }
    \end{center}
La probabilidad ingenua predice $\frac{12}{36}\approx 0.33$ para la probabilidad $P(A)$. En cambio, la regla de Laplace predice $\frac{11}{36}$. Para comprobarlo experimentalmente hemos incluido aquí una hoja de cálculo de Calc, llamada
\begin{center}
  \fichero{../ods/Tut03-DeMere1a.ods}{Tut03-DeMere1a.ods}
\end{center}
en la que se ha simulado ese lanzamiento. Recarga los valores unas cuantas
veces (con {\tt Ctrl+Mayús+F9}), para ver lo que sucede.

\begin{ejercicio}
\label{tut03:ejercicio07}
\quad
Escribe el código Python necesario para comprobar estos resultados. Debería resultar fácil, ahora que hemos visto como hacerlo para los dos juegos del Caballero de Méré.
Solución en la página \pageref{tut03:ejercicio07:sol}.
\qed
\end{ejercicio}


\section{Ejemplos de Probabilidad Geométrica.}
\label{tut03:sec:EjemplosProbabilidadGeometricaGeoGebra}

En la Sección \ref{curso-cap03:sec:ProbabilidadMasAllaReglaLaplace} (pág. \pageref{curso-cap03:sec:ProbabilidadMasAllaReglaLaplace}) hemos incluido varios ejemplos de un tipo de problemas que se denominan de Probabilidad Geométrica. Para visualizar esos problemas, ahora vamos a utilizar los primeros ficheros GeoGebra del curso.

\subsection{Probabilidad geométrica. Método de Montecarlo.}

\subsubsection{Un punto al azar en el segmento $[0,1]$.}

Vamos a usar Python para tratar de ilustrar las ideas que han aparecido en el Ejemplo \ref{curso-cap03:ejem:ProbabilidadGeometricaElegirPuntoIntervalo} del libro (pág. \pageref{curso-cap03:ejem:ProbabilidadGeometricaElegirPuntoIntervalo}). En ese ejemplo hemos tomado un número $n_0$ muy grande, por ejemplo $n_0=100000$, para definir $n_0+1$ puntos homogéneamente repartidos en el intervalo $[0,1]$. Usaremos Python para construir esos puntos. Para comprobar el resultado mostraremos los primeros y los últimos puntos. 
%Los últimos están tan cerca de $1$ que  los redondea a $1$ (al mostrarlos, pero no en las operaciones internas; ejecuta si quieres {\tt puntos[n0-1]==1} para comprobarlo):


<<purl=probGeom1, eval=FALSE, comment=NULL, echo=-1, engine='python'>>=
print("## ---- probGeom1ch001")
# n0 es el numero de subintervalos (puntos menos uno)

n0 = 100000

puntos = [ numero / n0 for  numero in range(0, n0 + 1)]

# imprimimos los primeros y los últimos puntos
print(puntos[0:5])
print(puntos[-5:])
@
\vspace{-5mm}
<<purl=FALSE, eval=FALSE, background=codeColor>>=
<<probGeom1ch001>>
@

Ahora vamos a elegir {\tt k} de esos puntos. Se trata de muestreo con reemplazamiento:

<<purl=probGeom1, eval=FALSE, comment=NULL, echo=-1, engine='python'>>=
print("## ---- probGeom1ch002")

# k es el numero de puntos elegidos

k = 10000

# importamos el módulo random y usamos seed para tener reproducibilidad

import random as rnd
rnd.seed(2016)

# y usamos choice con comprensión de listas para elegir k puntos

elegidos = [rnd.choice(puntos) for _ in range(0, k)]

# estos son los primeros 10 elegidos

print(elegidos[0:10])

@
\vspace{-5mm}
<<purl=FALSE, eval=FALSE, background=codeColor>>=
<<probGeom1ch002>>
@
Vamos a ver que proporción de ellos pertenece al intervalo $A = [2/3, 1]$. 
%Usaremos ideas que ya conocemos, como la equivalencia de {\tt TRUE} y {\tt FALSE} con {\tt 1} y {\tt 0}, respectivamente.

<<purl=probGeom1, eval=FALSE, comment=NULL, echo=-1, engine='python'>>=
print("## ---- probGeom1ch003")

enA = [punto for punto in elegidos if ((punto >= 2/3) and (punto<= 1))]

# comprobemos que funciona

print(enA[0:10])
@
\vspace{-5mm}
<<purl=FALSE, eval=FALSE, background=codeColor>>=
<<probGeom1ch003>>
@
Todos los puntos de la lista {\tt enA} son mayores que $2/3\approx 0.66\ldots$.
<<purl=probGeom1, eval=FALSE, comment=NULL, echo=-1, engine='python'>>=
print("## ---- probGeom1ch004")

# Ahora ya podemos calcular la proporción de puntos elegidos que pertenecen al intervalo:

proporcion = len(enA) / k
print(proporcion)

@
\vspace{-5mm}
<<purl=FALSE, eval=FALSE, background=codeColor>>=
<<probGeom1ch004>>
@
La proporción, como ves, es cercana al valor $\frac{1}{3}=$\Sexpr{1/3} que pronosticábamos.

\subsubsection{Lanzando dardos con GeoGebra. El método de Montecarlo para calcular áreas.}


Para ilustrar el Ejemplo \ref{curso-Cap03:ejem:ProbabilidadGeometricaMontecarlo} del libro (pág. \pageref{curso-Cap03:ejem:ProbabilidadGeometricaMontecarlo}), vamos a utilizar el fichero GeoGebra:
\begin{center}
  \fichero{../ggb/Cap03-MonteCarloAreaCirculo.ggb}{Cap03-MonteCarloAreaCirculo.ggb}
\end{center}
La parte (a) de la Figura \ref{tut03:fig:MontecarloAreaCirculo01} muestra lo que verás cuando lo abras con GeoGebra. El cuadrado inicial, al que llamaremos $C_1$, es de lado $4$, así que su área es 16. El interior del cuadrado contiene cinco puntos, porque el valor del deslizador inicialmente es $n=5$. Arrastra el deslizador con el ratón para ir viendo como se generan más puntos en el interior del cuadrado. Por ejemplo, la parte (b) de la Figura \ref{tut03:fig:MontecarloAreaCirculo01} muestra un ejemplo en el que se han generado  $n=2800$ puntos.
\begin{figure}[p]
    \begin{center}
    (a)\\[3mm]
    \includegraphics[width=15cm]{../fig/Tut03-43.png}\\[3mm]
    (b)\\[3mm]
    \includegraphics[width=15cm]{../fig/Tut03-44.png}
    \end{center}
  \caption{(a) Abriendo el fichero {\tt Cap03-MonteCarloAreaCirculo.ggb} con GeoGebra (b) Más puntos al mover el deslizador...}
  \label{tut03:fig:MontecarloAreaCirculo01}
\end{figure}
Si ahora marcas con el ratón la casilla rotulada {\em ``Área del cuadrado pequeño''}, verás aparecer un cuadrado más pequeño, de color rojo y centrado en el cuadrado más grande, al que vamos a llamar $C_2$. El lado de este cuadrado más pequeño es $2$, así que su área es $4$. Pero vamos a {\em fingir} que no sabemos cuánto vale el área, y vamos a tratar de calcular ese valor lanzando dardos, y contando la proporción de dardos que hacen blanco en el cuadrado pequeño. La idea subyacente es que ese número de dardos que aciertan en $C_2$ es proporcional al área de $C_2$, así que tenemos:
\[
\dfrac{\mbox{Dardos en $C_2$}}{\mbox{Total de dardos (en $C_1$)}} =
\dfrac{\mbox{Área de $C_2$}}{\mbox{Área de $C_1$}}
\]
En la Figura \ref{tut03:fig:MontecarloAreaCirculo02} se muestra ese proceso. Puedes ver que hemos lanzado $n=3000$ dardos, y que la proporción de aciertos en $C_2$ es $0.265$. Así que usando la ecuación anterior, y sabiendo que el área de $C_1$ es 16, estimamos que:
\[
\mbox{Área de $C_1$} \approx 16\cdot 0.265\approx 4.24
\]
Que, sin ser impresionante, es una primera aproximación. Prueba a mover el deslizador para ver como,  a medida que el número de puntos aumenta, las estimaciones son cada vez mejores. Puedes moverlos hasta $n=5000$. Y una vez que llegues a ese valor, pulsa {\tt Ctrl + R}. Cada vez que lo hagas, GeoGebra volverá a lanzar $5000$ nuevos dardos, y podrás ver una nueva estimación del área de $C_2$ (también puedes mover el deslizador ligeramente para conseguir lo mismo).

\begin{figure}[htbp]
    \begin{center}
    \includegraphics[width=15cm]{../fig/Tut03-45.png}\\[3mm]
    \end{center}
  \caption{Lanzando dardos para calcular el área del cuadrado pequeño.}
  \label{tut03:fig:MontecarloAreaCirculo02}
\end{figure}
Todo eso puede estar muy bien, pero el lector estará pensando que ya sabemos calcular (y de forma exacta) el área de un cuadrado. Al fin y al cabo de ahí hemos sacado el área  $16$ de $C_1$, para empezar. Es cierto. Pero lo interesante empieza ahora, el cuadrado era sólo calentamiento. Desmarca la casilla del cuadrado, y marca la del círculo. Vamos a llamar $C_3$ al círculo que aparece, y cuyo radio es $1$. Imagínate de nuevo que no conocemos la fórmula para el área del círculo.   El razonamiento es el mismo, y nos conduce a la relación:
\[
\dfrac{\mbox{Dardos en $C_3$}}{\mbox{Total de dardos (en $C_1$)}} =
\dfrac{\mbox{Área de $C_3$}}{\mbox{Área de $C_1$ (es 16)}}
\]
Por lo tanto,
\[
\mbox{Área de $C_3$}\approx 16\cdot \dfrac{\mbox{Dardos en $C_3$}}{\mbox{Total de dardos (en $C_1$)}}.
\]
Así que esto nos proporciona un procedimiento para aproximar el área del círculo (o de cualquier otra figura, por cierto) lanzando dardos. Eso empieza a parecer más interesante, ¿verdad?

Vuelve a repetir los pasos que dimos con el cuadrado, moviendo el deslizador hacia la derecha para ver como cambia la aproximación. Y cuando llegues a $5000$ dardos, usa {\tt Ctrl + R} para hacer varios experimentos. Al cabo de unos cuantos intentos espero que te hayas convencido de que el área del círculo tiene un valor cercano a $3.1$. El valor real, naturalmente, es $\pi$. Así que es posible calcular el valor de $\pi$ mientras juegas a los dardos (como ilustra la Figura \ref{tut03:fig:MontecarloAreaCirculo03})... siempre que estés dispuesto a jugar durante un buen rato, y no te esfuerces lo más mínimo en apuntar.
\begin{figure}[h!]
    \begin{center}
    \includegraphics[width=15cm]{../fig/Tut03-45a.png}\\[3mm]
    \end{center}
  \caption{Lanzando dardos para calcular el área del círculo, que es precisamente $\pi$.}
  \label{tut03:fig:MontecarloAreaCirculo03}
\end{figure}
Recuerda que lo esencial de estos experimentos es observar el vínculo que existe entre áreas y probabilidades. Cuanto mayor es el área de una figura, mayor es la probabilidad de acertarle con un dardo lanzado al azar.


\section{Operaciones simbólicas. Wiris, Wolfram Alpha.}
\label{tut03:sec:OperacionesSimbolicas}

Cuando empezamos a trabajar con probabilidades, usando al principio la Regla de Laplace, y luego con la Combinatoria, a menudo nos surge la necesidad de operar con fracciones,  como en el cálculo de esta fracción (que procede del Ejemplo \ref{curso-cap03:ejem:EjemploUrnasBayes}, pág. \pageref{curso-cap03:ejem:EjemploUrnasBayes}, de nuestro curso):
\[
\dfrac{\dfrac{3}{5}\cdot \dfrac{2}{6}}{\dfrac{3}{5}\cdot \dfrac{2}{6}+\dfrac{4}{5}\cdot\dfrac{4}{6}}=\dfrac{3}{11}
\]
Si intentas hacer esta cuenta en Python, para empezar tienes que ser cuidadoso con los paréntesis (se aplica la regla de ``más vale que sobren''), y escribir (mostramos una sesión de Jupyter):
<<chunk31, eval=FALSE, purl=FALSE, background=jupyterCol>>=
In [1]: ( (3/5) * (2/6) ) /( (3/5) * (2/6) + (4/5) * (4/6) )
Out[1]: 0.2727272727272727    
@
Fíjate en los espacios que hemos dejado para hacer la expresión más legible. La respuesta no es exactamente lo que queríamos. Para un problema como este, es muy posible que queramos ver el resultado en forma de fracción. El problema es que Python nos ha dado una respuesta {\sf numérico}, usando la representación de los números en forma decimal. Podríamos usar algunos módulos de Python para trabajar con fracciones. Hay varias alternativas y la más sencilla seguramente sea utilizar el módulo {\tt fractions}. Este módulo contiene una función llamada {\tt Fraction} con la que podemos definir fracciones utilizando código como {\tt Fraction(7, 12)} para representar la fracción $\frac{7}{12}$. Además una vez definidas esas fracciones podemos operar con ellas, en sumas, restas, productos y cocientes. Veamos cómo realizar la operación del ejemplo anterior con ese módulo {\tt fractions}:
<<eval=FALSE, purl=FALSE, background=jupyterCol>>=
In [1]: import fractions as fr

In [2]: ( fr.Fraction(3, 5) * fr.Fraction(2, 6) ) /( fr.Fraction(3, 5) *
fr.Fraction(2, 6) + fr.Fraction(4, 5) * fr.Fraction(4, 6) )
Out[2]: Fraction(3, 11)
@ 
La respuesta es la fracción
\[
\dfrac{3}{11}.
\]
Como ves, podemos trabajar con fracciones, pero no resulta demamasiado cómodo. A lo largo del curso nos vamos a encontrar varias veces con esta situación, en la que tenemos que trabajar con dos representaciones de un número: po un lado \Sexpr{ signif(( (3/5) * (2/6) ) /( (3/5) * (2/6) + (4/5) * (4/6) ), digits=10) } es una versión {\sf numérica} de la respuesta, en el sentido de {\em redondeada a unas cuantas cifras significativas} y, por lo tanto, es una respuesta aproximada. En cambio la respuesta en forma de fracción
\[
\dfrac{3}{11}
\]
es una respuesta {\sf simbólica}, y es absolutamente exacta: no hay ninguna pérdida de precisión. Usamos la dualidad {\em numerico/simbólico} en el sentido habitual en las matemáticas contemporáneas. En ese sentido, las cantidades
\[\sqrt{2},\qquad \pi\]
son cantidades simbólicas, mientras que sus contrapartes numéricas (con cinco cifras significativas) son:
\[1.4142,\qquad 3.1416\]
Y conviene insistir en que la representración numérica en un ordenador es una aproximación y conlleva una pérdida de precisión, que no sucede con las representaciones simbólicas. Por eso, para algunas operaciones del curso vamos a tener que recurrir a la ayuda de programas simbólicos. En las próximas secciones veremos algunos. ¿Por qué no trabjamos siempre con representaciones simbólicas, entonces? Pues porque los programas que las usan son mucho más complicados y en geneal mucho más lentos que los programas numéricos.  A menudo se busca un equilibrio usando un enfoque {\sf híbrido}, que combina parte simbólicas con otras numéricas dentro de un mismo cálculo.

\subsection{Wiris.}
\label{tut03:subsec:Wiris}

El programa Wiris CAS (de Computer Algebra System) es una creación de la empresa de software matemático {\em Maths for More}, con sede en Barcelona, y fundada por profesores y antiguos estudiantes de la Universitat Politècnica de Catalunya. Para utilizar el programa debemos estar conectados a internet.  El programa se usa en el navegador, a través de la Web, en la página de la propia empresa (que incluye publicidad insertada en la página):
\begin{center}
\link{http://www.wiris.net/demo/wiris/es/index.html}{http://www.wiris.net/demo/wiris/es/index.html}
\end{center}
o a través de las páginas Wiris que algunas Consejerías de Educación de distintas comunidades autónomas españolas ponen a libre disposición del público (tras llegar a acuerdos con la empresa, claro). Aquí tienes, por ejemplo, el enlace de la Comunidad de Madrid:
\begin{center}
\link{http://www.wiris.net/educa.madrid.org/wiris/es/index.html}{http://www.wiris.net/educa.madrid.org/wiris/es/index.html}
\end{center}
Usemos esta última. Al abrirla (es necesario tener instalado \link{http://www.java.com/es/download/}{Java} en el ordenador; si no sabes si lo tienes, o si puedes o debes instalarlo, consulta a tu \ninja{ninja informático),} el aspecto es este:
    \begin{center}
    \includegraphics[width=15.5cm]{../fig/Tut04-09.png}
    \end{center}
Wiris CAS nos permite escribir fórmulas matemáticas usando una notación muy parecida a la que usaríamos en el papel o la pizarra. Los símbolos y operaciones matemáticas están organizados por pestañas, pero para este primer ejemplo tan sencillo, todo lo que necesitamos está en la pestaña operaciones. Busca en ella el símbolo de fracción, que es el icono:
    \begin{center}
    \includegraphics[width=1cm]{../fig/Tut04-10.png}
    \end{center}
Púlsalo una vez con el ratón, y obtendrás
    \begin{center}
    \includegraphics[width=15cm]{../fig/Tut04-11.png}
    \end{center}
A partir de aquí las cosas son bastante intuitivas. Tienes que usar las teclas {\tt +} para la suma, y {\tt *} para la multiplicación, y usar el icono de fracción cada vez que quieras crear una nueva fracción. Tus primeros pasos te pueden llevar a algo como esto:
    \begin{center}
    \includegraphics[width=15.5cm]{../fig/Tut04-12.png}
    \end{center}
Ten en cuenta, para avanzar más rápido, que puedes seleccionar trozos de la fórmula con el ratón, y copiarlos y pegarlos. También, que en la pestaña {\tt Edición} tienes dos iconos en forma de flechas curvas, para deshacer y rehacer operaciones. Debes llegar a:
    \begin{center}
    \includegraphics[width=15.5cm]{../fig/Tut04-13.png}
    \end{center}
Y ahora viene lo bueno. Una vez que estés ahí, pulsa sobre el icono {\em igual} que hay a la derecha de la fórmula (o, con el cursor situado en la fórmula, pulsa {\tt Ctrl+Enter}). Al cabo de unos instantes (tu fórmula viaja por la red, se calcula, y la respuesta vuela de vuelta a tu ordenador), tendrás la respuesta:
    \begin{center}
    \includegraphics[width=15.5cm]{../fig/Tut04-14.png}
    \end{center}
Y Wiris CAS está listo para nuestra siguiente pregunta. Como ves, la respuesta es simbólica, no numérica, como queríamos. El inconveniente que encontramos es que la respuesta es realmente una imagen en la pantalla, no un número que podamos cortar y pegar para llevar a otro programa.

El cálculo de este ejemplo ha sido muy sencillo, pero a lo largo del curso iremos viendo más ejemplos en los que Wiris CAS nos puede ser de gran ayuda.

\subsection{Wolfram Alpha.}
\label{tut03:subsec:WolframAlpha}

Se trata también de una herramienta sólo accesible a través de la Web, en este caso en inglés, pero que también es muy interesante (por ejemplo, es fácilmente accesible desde teléfonos móviles o tablets). Al abrir la dirección
\begin{center}
\link{http://www.wolframalpha.com/}{http://www.wolframalpha.com/}
\end{center}
Wolfram Alpha te recibe con una pantalla como esta:
    \begin{center}
    \includegraphics[width=15.5cm]{../fig/Tut04-15.png}
    \end{center}
Debemos introducir lo que queremos calcular en el campo de entrada del centro de la ventana, usando en este caso la misma sintaxis que en Python:
    \begin{center}
    \includegraphics[width=15.5cm]{../fig/Tut04-16.png}
    \end{center}
En este caso, como ves, en cuanto hemos tecleado la operación, Wolfram Alpha nos ha mostrado la respuesta. Pero para hacer el ejemplo más completo, pulsa sobre el símbolo igual que hay al final del campo de entrada. Verás una pantalla parecida a esta,
    \begin{center}
    \includegraphics[width=15.5cm]{../fig/Tut04-17.png}
    \end{center}
en la que, desde luego, está la respuesta a tu pregunta, pero que contiene además mucha más información matemática sobre esa pregunta (más de la que seguramente nunca pensaste que existiera...) Como en el caso de Wiris CAS, apenas hemos rozado la superficie de lo que Wolfram Alpha es capaz de hacer, y volveremos más adelante a seguir aprendiendo como usarlo. Si quieres, puedes pulsar en el enlace {\tt Examples} que aparece bajo la barra de entrada para ver algunas de esas cosas.


\subsection{Suma de series con Wiris y Wolfram Alpha.}
\label{tut05:subsec:SeriesWirisWolfram}

Una serie es una suma con infinitos sumandos, como la suma
\[\dfrac{1}{2}+\dfrac{1}{2^3}+\dfrac{1}{2^5}+\dfrac{1}{2^7}+\cdots=\dfrac{2}{3}.\]
que vimos en el Ejemplo \ref{curso-cap03:ejem:LanzamientoMonedaHastPrimeraCara:2} (pág. \pageref{curso-cap03:ejem:LanzamientoMonedaHastPrimeraCara:2}) del libro. La teoría matemática de este tipo de sumas puede llegar a ser muy complicada. Pero nosotros nos vamos a quedar en la superficie, limitándonos a usar el ordenador para calcular los ejemplos que necesitemos.

El primer ejemplo, el más sencillo de todos, nos permite comprobar que la probabilidad total asignada en ese Ejemplo \ref{curso-cap03:ejem:LanzamientoMonedaHastPrimeraCara:2} es igual a 1, como exigen las propiedades básicas de la Probabilidad. Es decir, que queremos ver que:
\[ \dfrac{1}{2}+\dfrac{1}{2^2}+\dfrac{1}{2^3}+\dfrac{1}{2^4}+\cdots=1. \]
En la primera suma de esta sección sumábamos sólo los términos con exponentes impares, aquí los sumamos todos. Para calcular esta suma usaremos Wiris. Una vez abierto, en la pestaña {\tt Operaciones}, busca el icono del sumatorio
    \begin{center}
    \includegraphics[width=6.5cm]{../fig/Tut05-02.png}
    \end{center}
Y usa la paleta de símbolos de esa misma pestaña para escribir la serie, como en la siguiente figura. Un par de advertencias:
\begin{itemize}
  \item Encontrarás el símbolo de infinito positivo ($+\infty$) en la pestaña {\tt Símbolos}.
  \item Para escribir un exponente en Wiris puedes, desde luego, usar el botón \includegraphics[width=0.3cm]{../fig/Tut05-03.png} de la pestaña {\tt Operaciones}. Pero es más rápido usar el atajo de teclado {\tt Ctrl+$\uparrow$}.
\end{itemize}
    \begin{center}
    \includegraphics[width=5cm]{../fig/Tut05-04.png}
    \end{center}
Pulsa sobre el símbolo igual, y verás como Wiris te confirma que el resultado de sumar esa serie es un 1.

Ahora vamos a modificar ligeramente este cálculo, para obtener la suma de la serie de los términos con exponentes impares con la que empezamos esta sección. Para conseguir esto, vamos a modificar el exponente para que sólo tome valores impares. La forma de conseguirlo es sustituir, en el exponente, la variable $k$ por la fórmula $2\cdot k-1$. Porque, cuando $k$ recorre los valores $1,2,3,\ldots$, la fórmula $2\cdot k-1$ recorre a su vez los valores impares $1,3,5,\ldots$

Por lo tanto, hacemos ese cambio en Wiris, volvemos a pulsar el símbolo igual y obtenemos el resultado que se muestra en esta figura:
    \begin{center}
    \includegraphics[width=5cm]{../fig/Tut05-05.png}
    \end{center}

Como hemos dicho, las matemáticas de las series pueden ser muy complicadas. Queremos, para cerrar esta brevísima visita, añadir un ejemplo final, que ilustra un punto importante de esa teoría. La suma de esta serie
\[1+\dfrac{1}{2}+\dfrac{1}{3}+\cdots+\dfrac{1}{n}+\cdots\]
es infinito. Si le preguntas a Wiris, en este caso protestará, y dirá que no ha sido capaz de calcularlo (mira en la parte inferior de la pantalla). Lo malo es que a veces obtendremos esa misma respuesta con series que son ``demasiado complicadas para Wiris'', pero cuya suma es una cantidad finita. Si alguna vez necesitas necesitas más detalles, puedes consultar el
\link{http://www.wiris.net/educa.madrid.org/wiris/manual/es/html/tour/analisi.html\#series}{manual de Wiris } al respecto.

También  puedes probar con Wolfram Alpha. Ya sabes, la dirección es

\begin{center}
\link{http://www.wolframalpha.com/}{http://www.wolframalpha.com/}
\end{center}

Prueba a escribir en el campo de entrada
\begin{center}
\begin{minipage}{12cm}
    sum (1/n)
\end{minipage}
\end{center}

y obtendrás esta respuesta
    \begin{center}
    \includegraphics[width=8cm]{../fig/Tut05-06.png}
    \end{center}
La frase {\tt sum does not converge} (la suma --o serie-- no converge) se debe, en este caso, a que el resultado no es un número finito\footnote{Aparte de que el resultado sea infinito,  pueden ocurrir otras cosas. La serie converge cuando el resultado es un número finito, y no converge en cualquier otro caso.}

¿Por qué esta suma es infinito, mientras que las anteriores daban resultados finitos? La respuesta es que una serie es una suma de infinitos números,
cada vez más pequeños, y que el factor clave para que la suma sea finita es la {\em velocidad} a la que los números se hacen pequeños. Si se hacen
pequeños muy rápido,  la serie tendrá una suma finita (el resultado de la suma dependerá de cómo sea esa velocidad, en detalle). Pero si los números,
por el contrario, aunque se hagan pequeños, lo hacen despacio, entonces la suma se irá haciendo cada vez más grande, hasta valer infinito, {\em en el límite}.


\section{Combinatoria en Python.}
\label{tut03:sec:CombinatoriaPython}

\subsubsection*{El factorial en Python.}

Python nos proporciona numerosas herramientas para hacer cálculos en Combinatoria, desde las más básicas a algunas realmente sofisticadas. Para empezar, la función {\tt factorial}, que se usa como muestra este ejemplo de código ejectudo en Jupyter:
<<eval=FALSE,  purl=FALSE, background=jupyterCol>>=
In [1]: import math as m

In [2]: m.factorial(6)
Out[2]: 720
@
El factorial de un número entero $n\geq 1$ da como resultado el producto de todos los números desde $1$ hasta $n$. Otra manera de obtener ese mismo resultado, sin usar el módulo {\tt math}, consiste en usar un bucle {\tt for} para multiplicar esos números, como hemos hecho aquí: 
<<eval=FALSE,  purl=FALSE, background=jupyterCol>>=
In [1]: fact = 1

In [2]: n = 6

In [3]: for i in range(1, n + 1):
   ...:   fact = fact * i
   ...:   

In [4]: print(fact)
720
@
Nos hemos detenido en esto porque el factorial es sólo un caso especial del problema general de calcular el producto de una lista de números. Puesto que ya hemos visto varios casos en los que calculábamos la suma de todos los elementos de una lista de números (por ejemplo, al calcular la media aritmética) tal vez hayas pensado si no podríamos hacer algo parecido. Lamentablemente,  Python no dispone de una función tan sencilla como la función {\tt sum} que sirva para esto. Existen funciones que hacen eso, desde luego, pero siempre es necesario importarlas desde algún módulo.

\begin{ejercicio}
\label{tut03:ejercicio08}
\quad
El módulo {\tt numpy}, que ya hemos usado antes, contiene una función {\tt prod}. Busca información sobre esta función y úsala para calcular el factorial de 6. 
Solución en la página \pageref{tut03:ejercicio08:sol}.
\qed
\end{ejercicio}

Puesto que casi todos los cálculos de Combinatoria que vamos a usar en el curso se pueden expresar usando el factorial, podríamos parar aquí. Pero el factorial es una forma extremadamente poco eficiente de hacer cálculos, que nos causrá problemas en cuanto los números involucrados sean moderadamente grandes. Para trabajar de una forma más sensata tendremos que usar métodos que eviten los factoriales. A menudo usaremos funciones importadas de un módulo, que se han diseñado específicamente para hacer ese trabajo. 

Vamos a aprovechar la ocasión para concoer a otro de los protagonistas habituales de la computación científica en Python, el módulo {\tt scipy}. Puedes encontrar información sobre {\tt Scipy} en:
\begin{center}
\link{http://www.scipy.org/docs.html}{http://www.scipy.org/docs.html}
\end{center}

Este módulo se basa en {\tt numpy} pero lo extiende añadiéndole una colección más amplia de objetos, funciones y algoritmos matemáticos. Por ejemplo, para calcular números combinatorios, el módulo {\tt scipy} de Python nos ofrece la función {\tt choose}. ¡Pero espera un poco antes de lanzarte! Este es el primer caso en el que nos vamos a encontrar con un módulo organizado en {\sf submódulos}. La función {\tt comb} pertenece al submódulo {\tt misc} (de {\em miscelaneous}) dentro del módulo {\tt scipy}. La forma de utilizar esta función para calcular el número combinatorio
\[\binom{22}{7}\]
es esta:
<<eval=FALSE,  purl=FALSE, background=jupyterCol>>=
In [1]: import scipy.misc as spm

In [2]: spm.comb(22, 7, exact=True)
Out[2]: 170544
@

\subsubsection{Construyendo una lista de permutaciones y combinaciones con Python.}
\label{tut03:subsec:PermutacionesCombinacionesPython}

Con las funciones que hemos visto hasta ahora podemos calcular el número de permutaciones de $n$ objetos  y también números combinatorios como $\binom{10}{7}$. Pero a veces podemos estar interesados en obtener explícitamente todas esas permutaciones o combinaciones. Insistimos en que no se trata de saber cuántos hay, sino de construirlos y enumerarlos. La forma más sencilla de hacer esto en Python es usar el módulo {\tt itertools}, cuya documentación puedes encontrar en  
\begin{center}
\link{https://docs.python.org/3.5/library/itertools.html\#module-itertools}{https://docs.python.org/3.5/library/itertools.html\#module-itertools}
\end{center}
Entre otras funciones útiles este módulo incluye las funciones {\tt permutations} y {\tt combinations}. Por ejemplo, vamos a ver cómo utilizar utilizarlas para fabricar todas las listas posibles de tres elementos, elegidos de entre cuatro posibles. Para empezar, no admitimos repeticiones de los elementos. Entonces, si el orden no importa, estamos formando las combinaciones de cuatro elementos tomados de tres en tres. Y si el orden importa, entonces se trata de las variaciones (un inglés diría permutaciones) de cuatro elementos tomados de tres en tres (recuerda que en España, como hemos visto en el curso, distinguimos entre variaciones y permutaciones, pero la tradición anglosajona engloba dentro del término {\em permutations} tanto las variaciones como las permutaciones).

Los correspondientes comandos son estos. Para las combinaciones:
<<eval=FALSE,  purl=FALSE, background=jupyterCol>>=
In [1]: import itertools as it

In [2]: n = 4

In [3]: k = 3

In [4]: combinaciones = it.combinations(range(1, n + 1), k)

In [5]: print(combinaciones)
<itertools.combinations object at 0x110006368>

In [6]: print(list(combinaciones))
[(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4)]
@
Fíjate en que el resultado de usar {\tt combinations} no es una lsita, sino un objeto de tipo {\tt itertools.combinations}. Lo hemos convertido en una lsta usando {\tt list} para poder manipular y mostrar el resultado cómodamente.

Para las variaciones/permutaciones hacemos a continuación:
<<eval=FALSE,  purl=FALSE, background=jupyterCol>>=
In [7]: permutaciones = it.permutations(range(1, n + 1), k)

In [8]: print(list(permutaciones))
[(1, 2, 3), (1, 2, 4), (1, 3, 2), (1, 3, 4), (1, 4, 2), (1, 4, 3), (2, 1, 3), 
(2, 1, 4), (2, 3, 1), (2, 3, 4), (2, 4, 1), (2, 4, 3), (3, 1, 2), (3, 1, 4), 
(3, 2, 1), (3, 2, 4), (3, 4, 1), (3, 4, 2), (4, 1, 2), (4, 1, 3), (4, 2, 1),
(4, 2, 3), (4, 3, 1), (4, 3, 2)]
@
Como cabía esperar, al considerar el orden hay muchas más permutaciones que combinaciones. Concretamente seis veces más (¿por qué?)

No hay nada en las funciones {\tt permutations} y {\tt combinations} que nos obligue a trabajar con listas de números. Podemos igualmente usar cadenas de caracteres, como en este ejemplo en el que construimos las seis permutaciones posibles de tres palabras:
<<eval=FALSE,  purl=FALSE, background=jupyterCol>>=
In [1]: import itertools as it

In [2]: palabras = ["tres", "tristes", "tigres"]

In [3]: permutaciones = list(it.permutations(palabras, 3))

In [4]: print(permutaciones)
[('tres', 'tristes', 'tigres'), ('tres', 'tigres', 'tristes'), 
('tristes', 'tres', 'tigres'), ('tristes', 'tigres', 'tres'), 
('tigres', 'tres', 'tristes'), ('tigres', 'tristes', 'tres')]
@
En este caso hemos convertido el resultado de {\tt permutations} directamente en una lista.

\begin{ejercicio}
\label{tut03:ejercicio09}
\quad
¿Qué ocurre con {\tt combinations} y {\tt permutations} si la lista original contiene elementos repetidos? Prueba con la lista:
<<eval=FALSE>>=
dadoCargado = [1, 2, 3, 4, 5, 6, 6, 6]
@
y construye las combinaciones de los elementos de esta lista tomados de tres en tres. ¿Cuántos elementos tiene la lista que se obtiene como resultado? Y lo más importante ¿son todos distintos? Haz lo mismo para las permutaciones (advertencia: son muchas más, claro).
Solución en la página \pageref{tut03:ejercicio09:sol}.
\qed
\end{ejercicio}


\subsubsection*{Construyendo todas las posibles tiradas de un par de dados.}

Un problema relacionado con estos consiste en usar Python para construir la lista completa de tiradas de dos dados. Es decir, una lista que contenga los 36 pares posibles desde (1, 1), (1,2), hasta (6, 6). Fíjate que aquí se permiten repeticiones (así que no son variaciones) y además el orden es importante (no son combinaciones). De hecho se trata de construir lo que en el libro hemos llamado variaciones con repetición de $6$ elementos tomados de dos en dos (ver pág. \pageref{curso-cap03:ecu:VariacionesConRepeticion}). El objeto resultante coincide con lo que en Matemáticas se denomina el {\sf producto cartesiano} del conjunto $\{1, 2, 3, 4, 5, 6\}$ consigo mismo. Por eso no es extraño que la función del módulo {\tt itertools} que vamos a usar en este caso se llame {\tt product}. La usamos así (fíjate en que hemos convertido el resultado de {\tt product} directamente en una lista):
<<eval=FALSE,  purl=FALSE, background=jupyterCol>>=
In [1]: import itertools as it

In [2]: tiradas = list(it.product(range(1, 7), repeat=2))

In [3]: print(tiradas)
[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), 
 (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), 
 (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), 
 (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6), 
 (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6),
 (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]

In [4]: len(tiradas)
Out[4]: 36
@
Advertencia: hemos editado el resultado de Python para hacer más visualmente sencillo reconocer la estructura del resultado. 

¿Qué papel juega el argumento {\tt repeat=2} de la función? Descúbrelo haciendo este ejercicio:

\begin{ejercicio}
\label{tut03:ejercicio10}
\quad
\begin{enumerate}
  \item Cambia {\tt repeat=2} por {\tt repeat=3} en ese código y ejecútalo. ¿Qué sucede?
  \item Usa la lista {\tt tiradas} que obtienes con {\tt repeat=4} para calcular mediante la regla de Laplace la probabilidad de obtener al menos un seis en cuatro tiradas de un dado. Este método te permite obtener la probabilidad {\sf exacta} (por ejemplo, usando Python para imprimir tanto el denominador como el numerador de la fracción que se obtiene con la Regla de Laplace). Y de esa forma, tendrás la solución correcta del primer problema del Caballero de Méré.
\end{enumerate}
Solución en la página \pageref{tut03:ejercicio10:sol}.
\qed
\end{ejercicio}

\section{Combinatoria con Wiris y Wolfram Alpha}
\label{tut05:sec:CombinatoriaWirisWolfram}

En la Sección \ref{curso-cap03:sec:Combinatoria} (pág. \pageref{curso-cap03:sec:Combinatoria}) del libro hemos discutido la forma de calcular el número de
permutaciones, variaciones,  y combinaciones, con o sin repetición. Aquí vamos a aprender a utilizar algunas de  las herramientas software que conocemos para facilitar el trabajo en problemas de Combinatoria.

\subsection{Wiris}
\label{tut03:subsec:CombinatoriaWiris}

De nuevo en Wiris,  en la pestaña de Combinatoria, encontrarás los iconos de esta figura:
    \begin{center}
    \includegraphics[width=3cm]{../fig/Tut05-01.png}
    \end{center}
Los significados son evidentes, así que nos limitamos a invitarte  a que uses Wiris para calcular
el resultado de estos ejercicios:
\begin{ejercicio}
\label{tut03:ejercicio14}
\quad
\begin{enumerate}
  \item Permutaciones de 6 elementos.
  \item Variaciones de 100 elementos, tomados de 30 en 30.
  \item Combinaciones de 22 elementos, tomados de 7 en 7.
  \item Permutaciones con repetición de 10 elementos, divididos en grupos de elementos idénticos de $( 2,2,3,3)$ (de modo que hay $2$ del primer tipo, $2$ del segundo, $3$ del tercero y $3$ del cuarto tipo).
  \item Variaciones con repetición de 8 elementos, tomados de 13 en 13.
  \item Combinaciones con repetición de 4 elementos tomados de 6 en 6.
\end{enumerate}
Soluciones en la pág. \pageref{tut03:ejercicio14:sol}.
\qed
\end{ejercicio}
Aparte de calcular estos números, puedes usar Wiris para enumerar (es decir, hacer la lista, explícitamente) las variaciones o combinaciones. La forma de hacer esto es darle a Wiris como primer argumento una lista de los valores entre los que tiene que hacer la selección. Por ejemplo, para obtener la lista de variaciones de las 5 letras
\[\{a, b, c, d\}\]
tomadas de 2 en 2 (hay 12 posibles), hacemos esto (se muestra el resultado de ejecutar el comando)
    \begin{center}
    \includegraphics[width=12cm]{../fig/Tut05-07.png}
    \end{center}
Puedes aprender más sobre las capacidades combinatorias de Wiris en el manual:
\begin{center}
    \link{http://www.wiris.net/educa.madrid.org/wiris/manual/es/html/tour/combinatoria.html}{http://www.wiris.net/educa.madrid.org/wiris/manual/es/html/tour/combinatoria.html}
\end{center}

\subsection{Wolfram Alpha}
\label{tut03:subsec:CombinatoriaWolframAlpha}

Para usar Wolfram Alpha, debemos expresar (en inglés, claro) lo que deseamos calcular en esa mezcla de lenguaje natural y símbolos matemáticos, característica de este sistema. Por ejemplo, si escribes en el campo de entrada:
\begin{center}
    {\tt number of permutations of 23 elements}
\end{center}
obtendrás como respuesta
    \begin{center}
    \includegraphics[width=12cm]{../fig/Tut05-08.png}
    \end{center}
Si quieres copiar el resultado para poder pegarlo en otro programa, sitúa el ratón sobre ese resultado, y verás aparecer una barra de herramientas, como en la siguiente figura. Haz clic en la letra {\tt A} para obtener una versión copiable como texto del resultado.
    \begin{center}
    \includegraphics[width=12cm]{../fig/Tut05-09.png}
    \end{center}
Para ver más ejemplos de como usar Wolfram Alpha en Combinatoria, teclea {\tt Combinatorics} en la línea de entrada. Ten en cuenta, en cualquier caso, que muchos de los ejemplos que verás no son relevantes para nuestro curso. Así que asegúrate de, al menos, hacer el siguiente
\begin{ejercicio}
\label{tut03:ejercicio15}
\quad
Teclea en el campo de entrada de Wolfram Alpha los siguientes comandos y, para practicar, copia el resultado como texto en un editor de texto, como el Bloc de Notas.
\begin{enumerate}
  \item {\tt permutations of 6 elements}
  \item {\tt permutations(100,30)}
  \item {\tt combinations(22,7)}
  \item {\tt number of permutations of {a,a,b,b,c,c,c,d,d,d}}
  \item Aunque no hay una sintaxis directa (al menos, yo no la conozco), usa Wolpram Alpha para calcular el número de variaciones con repetición de 8 elementos, tomados de 13 en 13, y el de combinaciones con repetición de 4 elementos tomados de 6 en 6.
\end{enumerate}
Soluciones en la pág. \pageref{tut03:ejercicio15:sol}.
\qed
\end{ejercicio}


\section{Ejercicios adicionales y soluciones}
\label{tut03:sec:SolucionesEjerciciosAdicionales}

\subsection*{Ejercicios adicionales}
\label{tut03:subsec:EjerciciosAdicionales}

\begin{enumerate}
  \addtocounter{enumi}{16}

    %17
    \item Se lanzan dos dados. Hallar la probabilidad de estos sucesos:
        \begin{enumerate}
            \item la suma de los resultados es ocho y (simultáneamente) su diferencia es cuatro.
            \item la suma de los resultados es cinco y (simultáneamente) su producto es cuatro.
            \item la suma de los resultados sea mayor que 12.
            \item la suma de los resultados sea divisible entre 3.
        \end{enumerate}

    %18
    \item Hallar la probabilidad de que al lanzar una moneda dos veces se obtenga al menos una vez una cruz.

    %19
    \item En una caja hay seis fichas iguales numeradas del uno al 6. Se extraen una por una (sin reemplazarlas) todas las fichas de la caja. ¿Cuál es la probabilidad de que salgan en el orden natural? (Es decir, primero la ficha número uno, luego la dos, etc.)

    %20
    \item En un paquete hay 20 tarjetas numeradas del 1 al 20. Se escogen al azar dos tarjetas. ¿Cuál es la probabilidad de que las dos que se han elegido sean la número 1 y la número 20? ¿Hay alguna diferencia entre sacar las dos tarjetas a la vez, o sacarlas consecutivamente sin reemplazamiento? ¿Y si es con reemplazamiento (sacamos una, la devolvemos al paquete y sacamos otra al azar)?

    %21
    \item Una clase consta de 10 hombres y 20 mujeres. La mitad de los hombres y la mitad de las mujeres tienen los ojos castaños. Hallar la probabilidad de que una persona elegida al azar sea un hombre o tenga los ojos castaños.

    %22
    \item Las siguientes afirmaciones son necesariamente falsas. Explica por qué.
        \begin{enumerate}
        \item En un hospital, la probabilidad de que un paciente permanezca ingresado durante m\'as de dos d\'ias  es de 0.5. La probabilidad de que un paciente permanezca hospitalizado durante m\'as de un d\'ia es de 0.3.
        \item La probabilidad de que llueva el s\'abado es del 50\% y de que llueva el domingo es del 50\%. Por tanto, durante el fin de semana es seguro que llover\'a.
        \end{enumerate}

    %23
    \item Se escogen al azar tres lámparas de entre 15, y sabemos que de esas 15, cinco son defectuosas. ¿Cuál es la probabilidad de que al menos una de las tres elegidas sea defectuosa?



    \item Hallar la probabilidad de que al tirar tres dados aparezca el seis en uno de los dados (no importa cual), pero sólo en uno de ellos.


    %Soluci\'on: ambas son falsas teniendo en cuenta las propiedades de la probabilidad.

    \item En una baraja de cartas espa\~nola (40 cartas repartidas entre 4 palos) se desechan un n\'umero de cartas indeterminado. De las cartas que quedan se tiene una serie de probabilidades a la hora de sacar una carta:
        $$P(\{\hbox{sacar rey}\})=0.15,\quad P(\{\hbox{sacar bastos}\})=0.3,$$
        y adem\'as
        $$P(\{\hbox{sacar carta que no sea rey ni bastos}\})=0.6.$$
            \begin{enumerate}
            \item ¿Est\'a entre las cartas no desechadas el rey de bastos? En caso afirmativo, calcula la probabilidad de sacar esta carta.
            \item ¿Cu\'antas cartas hay?
            \end{enumerate}


    \item En cierta facultad, se sabe que (1) un 25\% de los estudiantes suspendió Matemáticas, (2) un 15\% suspendió Química y (c) un 10\% suspendió ambas. Se selecciona un estudiante al azar:
        \begin{enumerate}
            \item si suspendió Química, ¿cuál es la probabilidad de que también suspendiera Matemáticas?
            \item si suspendió Matemáticas, ¿cuál es la probabilidad de que también suspendiera Química?
            \item ¿Cuál es la probabilidad de que suspendiera al menos una de las dos?
        \end{enumerate}

    \item En un experimento aleatorio, el suceso A tiene probabilidad 0.5, mientras que el suceso B tiene probabilidad 0.6. ¿Pueden ser los sucesos A y B incompatibles?

    \item Un hospital tiene dos quirófanos en funcionamiento. En el primero se han producido incidentes en el 20\% de sus operaciones y el segundo sólo en el 4\%. El número de operaciones es el mismo en ambos quirófanos. La inspección hospitalaria analiza el expediente de una operación, elegido  al azar y observa que en esa operación se produjo un incidente. ¿Cuál es la probabilidad de que la operación se realizara en el primer quirófano?

%    \item En cierta población el porcentaje de personas que padecen una determinada enfermedad es del $2\%$. Para identificar a los enfermos se dispone de una prueba diagnóstica. Esa prueba no es perfecta: resulta positiva en el $95\%$ de las personas que padecen la enfermedad, pero también resulta positiva en el $3\%$ de las personas sanas (falsos positivos).  Calcular la probabilidad de que una persona con prueba positiva padezca realmente la enfermedad.

    \item Un equipo de investigación está preparando un nuevo test para el diagnóstico de la enfermedad de Alzheimer. El test se ha probado en una muestra aleatoria con 450 pacientes diagnosticados con Alzheimer y una muestra aleatoria independiente de 500 pacientes que no presentan síntomas de la enfermedad. La siguiente tabla resume los resultados del ensayo:
        \begin{center}
            \begin{tabular}{llccc}
            &&\multicolumn{3}{c}{\underline{\bf Padecen Alzheimer}}\\

                                      &          & Sí  & No  & Total\\
            \hline
  \underline{\bf Resultado del  Test} & Positivo & 436 & 5   & 441  \\
                                      & Negativo & 14  & 495 & 509  \\
            \hline
                                      & Total    & 450 & 500 & 950  \\
            \hline
            \end{tabular}
        \end{center}
    Con estos datos, responder a las siguientes preguntas:
    \begin{enumerate}
        \item ¿Cuál es la probabilidad de que un sujeto sano haya dado positivo en el test?
        \item ¿Cuál es la probabilidad de que un sujeto enfermo haya dado negativo en el test?
        \item Sabiendo que un sujeto ha dado positivo en el test, ¿cuál es la probabilidad de que esté enfermo?
        \item  Sabiendo que un sujeto ha dado negativo en el test, ¿cuál es la probabilidad de que esté sano?
    \end{enumerate}
    %\setcounter{cont01}{\theenumi}

    \item Una empresa produce anillas para identificaci\'on de tortugas marinas en tres fábricas. El volumen de producci\'on diario es de 500, 1000 y 2000 unidades respectivamente. Se sabe  que la fracci\'on de producci\'on defectuosa de las tres fábricas es de 0.005, 0.008, 0.010 respectivamente. Si se selecciona una anilla de forma aleatoria del total de producci\'on de un d\'ia y se descubre que es defectuosa, ?`de qu\'e fábrica es más probable que provenga esa anilla?.




  \item Usa R para simular el experimento que se describe en el Ejemplo \ref{curso-Cap03:probabilidadCondicionadaLanzamientoDosDados} del libro (pág. \pageref{curso-Cap03:probabilidadCondicionadaLanzamientoDosDados}). Por si te sirve de guía visual, en la hoja de cálculo (del programa Calc):
\begin{center} \fichero{../ods/Cap03-Lanzamientos2Dados-ProbabilidadCondicionada.ods}{Cap03-Lanzamientos2Dados-ProbabilidadCondicionada.ods}
\end{center}
se ha realizado una simulación para comprobar estos resultados.\\
Una extensión natural de este ejemplo es tratar de calcular $P(S|D)$. ¿Puedes modificar la hoja de cálculo para simular este otro caso?

  \item  Usa R para simular el experimento que se describe en el Ejemplo \ref{curso-cap03:ejem:ProbailidadTotalEjemploUrnas} del libro (pág. \pageref{curso-cap03:ejem:ProbailidadTotalEjemploUrnas}), y que ilustramos con el fichero  Calc
      \begin{center}
        \fichero{../ods/Cap03-ProbabilidadesTotales-Urnas.ods}{Cap03-ProbabilidadesTotales-Urnas.ods}
      \end{center}

  \item Usa R para simular los experimentos de los Ejemplos \ref{curso-cap03:ejem:BombillasDefectuosas} y \ref{curso-cap03:ejem:probabilidadLanzamientoMonedas} del libro (pág. \pageref{curso-cap03:ejem:BombillasDefectuosas})



  \item Elegimos al azar cinco números del $1$ al $10$, con reemplazamiento. Puedes pensarlo así: en una caja hay $10$ bolas numeradas del $1$ al $10$. Sacamos una bola, anotamos el número, devolvemos la bola a la caja, y la agitamos bien. ¿Cuál es la probabilidad de que no haya repeticiones y, por tanto, obtengamos cinco números distintos?

    \item De entre los números naturales $1,2,\ldots,20$ se seleccionan cinco al azar sin reemplazamiento. Calcular la probabilidad de que: (a) los cinco sean pares. (b) exactamente dos de ellos sean múltiplos de 3. (c) dos sean impares y tres impares.

    \item En la lotería primitiva gana quien acierta 6 números de entre 64 sin importar el orden en el que salgan. ¿Cuál es la probabilidad de ganar con una única apuesta?


    \item De las 28 fichas del dominó, se extraen dos al azar (sin remplazamiento). ¿Cuál es la probabilidad de que con ellas se pueda formar una cadena, conforme a las reglas del juego (debe haber un número que aparezca en ambas fichas)?

    \item Calcular la probabilidad de que un número de cuatro cifras (una matrícula, o un pin)
    \begin{itemize}
      \item tenga cuatro cifras diferentes.
      \item tenga alguna cifra repetida.
      \item tenga exactamente dos cifras iguales.
      \item tenga dos parejas de cifras iguales (pero distintas entre sí).
      \item tenga exactamente tres cifras iguales.
      \item tenga todas las cifras iguales.
    \end{itemize}


  \item {\bf ``La paradoja del cumpleaños''.} Si en una sala hay $367$ personas, entonces, con total seguridad, habrá dos personas con la misma fecha de cumpleaños (hemos usado $367$ para cubrir incluso el caso de los años bisiestos, por si alguien de la sala nació el $29$ de Febrero). Así que, si llamamos
      $$A_n= \{\mbox{al menos dos de las $n$ personas cumplen años el mismo día}\}$$
      entonces $P(A_{367})=1$. ¿Cuántas personas tiene que haber en la sala para que la probabilidad $P(A_{n})$ sea mayor que $1/2$? Muchas menos de las que imaginas. Empieza por calcular ¿Cuánto vale $P(A_{5})$ usando el ejercicio anterior.\\
      Este resultado se conoce como ``la paradoja del cumpleaños'', aunque no tiene nada de paradójico. Lo único que realmente demuestra este resultado es que, como hemos señalado en el curso, la intuición en materia de probabilidades es, en general, para la mayoría de nosotros, muy pobre.
\end{enumerate}

\subsection*{Soluciones de algunos ejercicios}

\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio01}, pág. \pageref{tut03:ejercicio01}}
\label{tut03:ejercicio01:sol}\quad\\

<<ejercicio01sol, purl=FALSE>>=
set.seed(2014)
(caja=rep( 1:5, c(35, 15, 10, 10, 30) ))
(sorteo1 = sample(caja, 20, replace = TRUE))
(sorteo2 = sample(caja, 20, replace = FALSE))
(tabFrecAbs1  = table(sorteo1))
(tabFrecRel1  = table(sorteo1) / length(sorteo1) )
(tabFrecAbs2  = table(sorteo2))
(tabFrecRel2  = table(sorteo2) / length(sorteo2) )
@

\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio02}, pág. \pageref{tut03:ejercicio02}}
\label{tut03:ejercicio02:sol}\quad\\

Cuando {\tt byrow=FALSE} (que es la opción por defecto), los elementos se colocan por columnas.
<<ejercicio02sol, purl=FALSE>>=
(dosPartidas = matrix(head(dado4000, 8), ncol = 4, byrow = FALSE))

(dosPartidas = matrix(head(dado4000, 8), ncol = 4))
@


\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio03}, pág. \pageref{tut03:ejercicio03}}
\label{tut03:ejercicio03:sol}\quad\\

<<ejercicio03sol, purl=FALSE>>=
(M = matrix(1:36, nrow=4, byrow=TRUE) )
@

\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio04}, pág. \pageref{tut03:ejercicio04}}
\label{tut03:ejercicio04:sol}\quad\\

<<ejercicio04sol, purl=FALSE>>=
dim(M)= c(4, 9)
M
@

\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio05}, pág. \pageref{tut03:ejercicio05}}
\label{tut03:ejercicio05:sol}\quad\\

Los vectores {\em puros} de R no tienen dimensión cuando son creados. La adquieren al convertirlos en matrices.
<<ejercicio05sol, purl=FALSE>>=
unVector = 1:10
dim(unVector)
class(unVector)
M = matrix(unVector, nrow=1)
dim(M)
class(M)
a=letters[1:12]
(Ma = matrix(a, nrow=3))
@


\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio06}, pág. \pageref{tut03:ejercicio06}}
\label{tut03:ejercicio06:sol}\quad\\

<<ejercicio06sol, purl=FALSE>>=
(letras = matrix(letters[1:12], nrow=4, byrow=TRUE))
dim(letras)
dim(letras)=c(3,4)
letras
@

\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio07}, pág. \pageref{tut03:ejercicio07}}
\label{tut03:ejercicio07:sol}\quad\\

<<ejercicio07sol_a, echo=FALSE, results='hide', purl=FALSE>>=
    (W = matrix(1:15, nrow=3, byrow=TRUE))
@
La comprobación es:
<<ejercicio07sol_b, purl=FALSE>>=
    t(W)
    dim(W) = c(5,3)
    W
@



\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio07a}, pág. \pageref{tut03:ejercicio07a}}
\label{tut03:ejercicio07a:sol}\quad\\

<<ejercicio07asol_a, echo=FALSE, results='hide', purl=FALSE>>=
    (M = matrix(1:36, nrow = 4, byrow=TRUE))
@
<<ejercicio07asol_b, purl=FALSE>>=
    apply(M, 1, sd)
    apply(M, 2, median)
    apply(M, 2, summary)
    class(apply(M, 2, summary))
@


\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio08}, pág. \pageref{tut03:ejercicio08}}
\label{tut03:ejercicio08:sol}\quad\\

<<chunk08sola, eval=FALSE,  purl=FALSE, background=jupyterCol>>=
In [14]: import numpy as np

In [15]: np.prod(range(1, 7))
Out[15]: 720
@



\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio09}, pág. \pageref{tut03:ejercicio09}}
\label{tut03:ejercicio09:sol}\quad\\

<<ejercicio09sol_a, echo=FALSE, results='hide', purl=FALSE>>=
    B = matrix(1:100, nrow=10)
@
<<ejercicio09sol_b, purl=FALSE>>=
    (B = cbind(A, A[, 1]^2))
@


\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio10}, pág. \pageref{tut03:ejercicio10}}
\label{tut03:ejercicio10:sol}\quad\\

<<ejercicio10sol, purl=FALSE>>=
    which(rowSums(esSeis) == max(rowSums(esSeis)))
@

\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio11}, pág. \pageref{tut03:ejercicio11}}
\label{tut03:ejercicio11:sol}\quad\\

Puedes ejecutar varias veces este código (que puedes abrir en el fichero adjunto \fichero{../TutorialesR/code/Tut03-DeMere2.R}{Tut03-DeMere2.R}) para experimentar.

<<ejercicio11solExternalCode, cache=FALSE, echo=FALSE, purl=FALSE>>=
read_chunk('../TutorialesR/code/Tut03-DeMere2.R')
@

<<ejercicio11sol, purl=FALSE>>=
@

\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio12}, pág. \pageref{tut03:ejercicio12}}
\label{tut03:ejercicio12:sol}\quad\\

El código (que puedes abrir en el fichero adjunto \fichero{../TutorialesR/code/Tut03-DeMere1a.R}{Tut03-DeMere1a.R}) es una adaptación sencilla del que corresponde al primer juego del Caballero de Méré. Puedes ejecutarlo varias veces para comprobar que el resultado se parece más a $\frac{11}{36}\approx\Sexpr{11/36}$ que a $\frac{12}{36}\approx\Sexpr{1/3}$.
<<ejercicio12solExternalCode, cache=FALSE, echo=FALSE, purl=FALSE>>=
read_chunk('../TutorialesR/code/Tut03-DeMere1a.R')
@


<<ejercicio12sol, purl=FALSE>>=
@


\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio13}, pág. \pageref{tut03:ejercicio13}}
\label{tut03:ejercicio13:sol}\quad\\

Puedes averiguarlo preguntando a R de esta forma:
<<ejercicio13sol, purl=FALSE>>=
class(permutations(4,3) )
class(combinations(4,3) )
@
Como puedes ver, lo que hemos obtenido es un objeto de tipo {\tt matrix}.


\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio14}, pág. \pageref{tut03:ejercicio14}}
\label{tut03:ejercicio14:sol}\quad\\

\begin{enumerate}
  \item $720$.
  \item $7791097137057804874587232499277321440358327700684800000000$.
    Este número podría representar el número de subgrupos distintos de 30 alumnos, que podemos formar a partir de una clase de 100 alumnos. Su orden de magnitud es de $10^{57}$. Para que te hagas una idea, el número estimado de estrellas en el universo es del orden de $10^{24}$.
  \item $170544$.
  \item $25200$.
  \item $549755813888$.
  \item $84$.
\end{enumerate}

\paragraph{\bf $\bullet$ Ejercicio \ref{tut03:ejercicio15}, pág. \pageref{tut03:ejercicio15}}
\label{tut03:ejercicio15:sol}\quad\\

Todas las preguntas aparecen en el Ejercicio \ref{tut03:ejercicio14}; consulta las respuesta a ese ejercicio.

\paragraph{\bf $\bullet$ Ejercicio 23.}
\label{tut03:ejercicio23:sol}\quad\\

Código R para comprobar experimentalmente el resultado:
<<ejercicio23sol, purl=FALSE>>=
#set.seed(2014)
n = 10000

# Creo una matriz vacía de n filas y tres columnas
ensayos = matrix(nrow = n, ncol = 3)

# Ahora para cada número i desde 1 hasta n,
for(i in 1:n){
  # hago una elección al azar de tres lamparas ¡¡sin reemplazamiento!!:
  tresLamparas = sample(1:15, 3)
  # y la guardo en la fila número i de la matriz
  ensayos[i, ] = tresLamparas
}
# La matriz ensayos contiene n repeticiones del experimento
head(ensayos, 10)

# supongamos que las defectuosas corresponden a los numeros del 1 al 5
# miramos si cada elemento de la matriz es una lampara defectuosa

esDefectuosa = (ensayos<= 5)

# El aspecto de esDefectuosa es este:
head(esDefectuosa, 10)

# Para que en un experimento (fila de la matriz) no haya ninguna defectuosa
# la suma de esa fila tiene que ser cero

sinDefecto = (rowSums(esDefectuosa) == 0)

# Podemos ver cuantas filas hay con y sin defecto:
table(sinDefecto)

# Y para estimar la probabilidad (mediante la frecuencia relativa) basta con hacer:

table(sinDefecto) / n
@



%#########################################################################################
%#########################################################################################
\vspace{2cm} \hrule
\quad\\
Fin del Tutorial-03. ¡Gracias por la atención!


%
%\newpage
%\addcontentsline{toc}{section}{Guía de trabajo.}
%\includepdf[pages={1-},scale=0.90]{03-GuiaDeTrabajo.pdf}

\end{document}



